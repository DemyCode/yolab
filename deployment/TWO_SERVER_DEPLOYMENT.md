# YoLab Two-Server Deployment Guide

## Overview

YoLab now supports a two-server architecture for better resource isolation and scalability:

- **Server 1 (frps-server)**: Runs ONLY the FRP server for handling tunnel connections
- **Server 2 (services-stack)**: Runs backend API + DNS server + PostgreSQL database

## Architecture Diagram

```
┌─────────────────────┐
│   FRPS Server       │
│   (yolab-frps)      │
│                     │
│   - FRP Server      │
│   - Port 7000       │
│   - CPX22           │
└──────────┬──────────┘
           │
           │ Auth requests
           │ (HTTP to services-stack:5000)
           │
           ▼
┌─────────────────────┐
│  Services Stack     │
│  (yolab-services)   │
│                     │
│  - Backend API      │
│  - DNS Server       │
│  - PostgreSQL       │
│  - Port 5000, 53    │
│  - CPX22            │
└─────────────────────┘
```

## Cost Breakdown

- **FRPS Server**: CPX22 (~€8/month)
- **Services Stack**: CPX22 (~€8/month)
- **Total**: ~€16/month

## Prerequisites

1. Hetzner Cloud account with API token
2. SSH key pair generated and uploaded to Hetzner Cloud
3. Domain name with DNS access
4. Terraform installed locally (or use GitHub Actions)
5. Git repository with YoLab code

## Deployment Steps

### Step 1: Configure Terraform Variables

Create `deployment/terraform/terraform.tfvars`:

```hcl
# Hetzner Cloud
hcloud_token      = "YOUR_HETZNER_API_TOKEN"
hetzner_location  = "nbg1"  # or fsn1, hel1, ash, etc.

# SSH Keys
ssh_public_key  = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAI... user@host"
ssh_private_key = <<-EOT
-----BEGIN OPENSSH PRIVATE KEY-----
...
-----END OPENSSH PRIVATE KEY-----
EOT
ssh_key_name    = "yolab-deployment-key"

# Server Configuration
frps_server_type     = "cpx22"
services_server_type = "cpx22"
environment          = "production"

# Domain & Repository
domain   = "yourdomain.com"
repo_url = "https://github.com/yourusername/yolab.git"

# Database
postgres_db       = "frp_services"
postgres_user     = "frp_user"
postgres_password = "GENERATE_STRONG_PASSWORD_HERE"
```

### Step 2: Deploy Infrastructure

```bash
cd deployment/terraform

# Initialize Terraform
terraform init

# Review the plan
terraform plan

# Deploy both servers
terraform apply
```

Terraform will:
1. Create two Hetzner servers (frps-server + services-stack)
2. Generate configuration files:
   - `deployment/nixos/ignored/config-frps.json`
   - `deployment/nixos/ignored/config-services.json`
3. Deploy NixOS to both servers via nixos-anywhere
4. Configure and start all services

**Deployment time**: ~15-20 minutes

### Step 3: Verify Deployment

After deployment completes, Terraform will output connection details:

```bash
# View outputs
terraform output

# SSH into FRPS server
ssh root@<frps-server-ip>
systemctl status frps

# SSH into Services Stack
ssh root@<services-stack-ip>
docker ps
curl http://localhost:5000/health
```

### Step 4: Configure DNS

Configure these DNS records in your DNS provider:

| Type  | Name | Value | Purpose |
|-------|------|-------|---------|
| A     | @    | `<frps-server-ipv4>` | Root domain → FRPS |
| AAAA  | @    | `<frps-server-ipv6>` | Root domain → FRPS |
| A     | *    | `<frps-server-ipv4>` | Wildcard → FRPS |
| AAAA  | *    | `<frps-server-ipv6>` | Wildcard → FRPS |
| A     | api  | `<services-stack-ipv4>` | API endpoint |
| AAAA  | api  | `<services-stack-ipv6>` | API endpoint |
| A     | ns1  | `<services-stack-ipv4>` | DNS server |
| AAAA  | ns1  | `<services-stack-ipv6>` | DNS server |
| NS    | @    | `ns1.yourdomain.com` | Nameserver delegation (optional) |

**Get DNS values from Terraform**:
```bash
terraform output dns_configuration
```

### Step 5: Test Connectivity

```bash
# Test backend API
curl http://api.yourdomain.com:5000/health
# Expected: {"status":"ok"}

# Test DNS resolution
dig @ns1.yourdomain.com yourdomain.com
# Should return FRPS server IP

# Test FRPS server (from client)
# Configure FRP client to connect to yourdomain.com:7000
```

## Configuration Files

### Auto-Generated by Terraform

Terraform automatically generates two configuration files:

1. **`deployment/nixos/ignored/config-frps.json`**
   - FRPS server configuration
   - Contains: domain, SSH keys, networking (auth_plugin_addr points to services-stack)

2. **`deployment/nixos/ignored/config-services.json`**
   - Services stack configuration
   - Contains: domain, SSH keys, database credentials, networking

### Manual Configuration (Alternative)

If not using Terraform, you can manually create config files:

```bash
# Copy examples
cp deployment/nixos/ignored/config-frps.json.example \
   deployment/nixos/ignored/config-frps.json

cp deployment/nixos/ignored/config-services.json.example \
   deployment/nixos/ignored/config-services.json

# Edit both files with your values
vim deployment/nixos/ignored/config-frps.json
vim deployment/nixos/ignored/config-services.json
```

Then deploy manually using nixos-anywhere:
```bash
# Deploy FRPS server
nixos-anywhere --flake .#frps-server root@<frps-server-ip>

# Deploy Services Stack
nixos-anywhere --flake .#services-stack root@<services-stack-ip>
```

## Networking Details

### FRPS Server → Services Stack Communication

- **Auth Plugin Endpoint**: `http://<services-stack-ipv4>:5000/handler`
- **Protocol**: HTTP POST with JSON payload
- **Firewall**: Services-stack allows TCP port 5000 from all sources

**Security Note**: The backend API is publicly accessible. To restrict access:

1. Add firewall rules on services-stack to only allow FRPS server IP:
   ```nix
   networking.firewall.extraCommands = ''
     iptables -A INPUT -p tcp --dport 5000 -s <frps-server-ipv4> -j ACCEPT
     iptables -A INPUT -p tcp --dport 5000 -j DROP
   '';
   ```

2. Or use Hetzner Cloud private networking (requires additional Terraform configuration)

### Client Connection Flow

```
1. FRP Client connects to frps-server:7000
2. FRPS server calls services-stack:5000/handler for auth
3. Services-stack validates token + service_id
4. FRPS accepts/rejects connection
5. DNS queries go to services-stack:53
6. DNS server queries services-stack:5000/internal/dns/resolve
```

## Troubleshooting

### FRPS can't connect to services-stack

**Symptom**: FRPS logs show connection refused to auth plugin

**Checks**:
```bash
# On FRPS server
curl http://<services-stack-ip>:5000/health

# On services-stack
docker ps
docker logs frp-backend
```

**Fix**: Ensure firewall allows port 5000, backend is running on 0.0.0.0

### Client connections rejected

**Symptom**: FRP client connection fails

**Checks**:
```bash
# On FRPS server
journalctl -u frps -f

# On services-stack
docker logs frp-backend
```

**Common issues**:
- Invalid token
- Service not registered
- Backend API unreachable from FRPS

### DNS not resolving

**Symptom**: Client subdomains don't resolve

**Checks**:
```bash
# Test DNS server
dig @<services-stack-ip> test.yourdomain.com

# Check DNS server logs
docker logs frp-dns-server

# Check backend API
curl http://<services-stack-ip>:5000/internal/dns/resolve/test
```

## Maintenance

### Update Services

```bash
# SSH into services-stack
ssh root@<services-stack-ip>

# Update YoLab code
cd /opt/yolab-services
git pull

# Restart services
systemctl restart yolab-deploy
```

### Update FRPS Server

```bash
# SSH into FRPS server
ssh root@<frps-server-ip>

# Update configuration if needed
vim /etc/frps/frps.ini

# Restart FRPS
systemctl restart frps
```

### View Logs

```bash
# FRPS server
ssh root@<frps-server-ip>
journalctl -u frps -f

# Services stack
ssh root@<services-stack-ip>
docker logs -f frp-backend
docker logs -f frp-dns-server
docker logs -f frp-postgres
```

## Scaling

### Add More FRPS Servers

To scale horizontally across regions:

1. Add more `hcloud_server` resources in `main.tf`
2. Point all FRPS servers to the same services-stack
3. Use DNS load balancing or GeoDNS
4. Update Terraform outputs for multiple FRPS servers

### Upgrade Server Specs

```bash
# Update terraform.tfvars
frps_server_type     = "cpx31"  # 4 vCPU, 8GB RAM
services_server_type = "cpx41"  # 8 vCPU, 16GB RAM

# Apply changes
terraform apply
```

**Note**: Requires server recreation (downtime)

## Rollback

### Terraform State

```bash
# View state
terraform show

# Revert to previous state
terraform state pull > backup.tfstate
terraform state push backup.tfstate
```

### NixOS Generations

```bash
# SSH into server
ssh root@<server-ip>

# List generations
nixos-rebuild list-generations

# Rollback
nixos-rebuild --rollback
```

## Backup Strategy

### Database Backups

```bash
# On services-stack
docker exec frp-postgres pg_dump -U frp_user frp_services > backup.sql

# Restore
docker exec -i frp-postgres psql -U frp_user frp_services < backup.sql
```

### Configuration Backups

- Store `terraform.tfvars` securely (contains secrets)
- Commit generated `config-*.json` to private repository
- Export Terraform state: `terraform state pull > state-backup.json`

## Security Recommendations

1. **Firewall**: Restrict backend API to FRPS server IP only
2. **SSH**: Use key-based auth only (already configured)
3. **Database**: Use strong passwords (auto-generated in Terraform)
4. **Tokens**: Rotate account tokens periodically
5. **Updates**: Keep NixOS and Docker images updated
6. **Monitoring**: Set up alerting for service failures

## Support

- **Issues**: GitHub Issues
- **Logs**: Check systemd journals and Docker logs
- **Health checks**: Use Terraform outputs for health check commands

---

**Deployment Status**: Production-ready
**Last Updated**: 2026-02-03
