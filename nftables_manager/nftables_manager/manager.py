#!/usr/bin/env python3
"""
nftables Manager Service for YoLab

Periodically fetches service configurations from the backend API
and applies nftables rules to route IPv6 traffic to FRPS internal ports.

Architecture:
- User connects to: [2a01:4f8:1c19:b96::a]:8080
- nftables DNAT: [IPv6::a]:8080 → 127.0.0.1:38012
- FRPS tunnels: 127.0.0.1:38012 → FRPC client → localhost:8080
"""

import logging
import subprocess
import sys
import time
from pathlib import Path
from typing import List

import requests

from pydantic_settings import BaseSettings, SettingsConfigDict

logger = logging.getLogger("nftables_manager")


class EnvironmentSettings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=str(Path(__file__).parent.parent / ".env"),
        env_file_encoding="utf-8",
        case_sensitive=False,
        extra="ignore",
    )

    backend_url: str
    poll_interval: int
    nftables_file: str
    log_level: str

    def model_post_init(self, __context):
        pprint(self)


settings = EnvironmentSettings()


def fetch_rules() -> List[dict]:
    """Fetch active service rules from backend API.

    Returns:
        List of rule dictionaries with fields:
        - service_id: int
        - sub_ipv6: str
        - client_port: int
        - protocol: str (tcp or udp)
        - frps_internal_port: int

    Raises:
        requests.RequestException: If API call fails
    """
    try:
        response = requests.get(f"{settings.BACKEND_URL}/services", timeout=5)
        response.raise_for_status()
        data = response.json()
        return data["rules"]
    except requests.RequestException as e:
        logger.error(f"Failed to fetch rules from backend: {e}")
        raise


def generate_nftables_config(rules: List[dict]) -> str:
    """Generate nftables configuration from service rules.

    Creates an IPv6 NAT table with DNAT rules that redirect traffic
    from user-facing IPv6:port to internal FRPS IPv4:port.

    Args:
        rules: List of service rule dictionaries

    Returns:
        Complete nftables configuration as string
    """
    lines = [
        "#!/usr/sbin/nft -f",
        "",
        "# YoLab IPv6 to IPv4 NAT rules",
        "# Auto-generated by nftables-manager",
        f"# Generated at: {time.strftime('%Y-%m-%d %H:%M:%S')}",
        f"# Total rules: {len(rules)}",
        "",
        "flush ruleset",
        "",
        "table ip6 nat {",
        "    chain prerouting {",
        "        type nat hook prerouting priority -100; policy accept;",
        "",
    ]

    # Add DNAT rule for each service
    for rule in rules:
        service_id = rule["service_id"]
        sub_ipv6 = rule["sub_ipv6"]
        client_port = rule["client_port"]
        protocol = rule["protocol"]
        internal_port = rule["frps_internal_port"]

        # Add comment and DNAT rule
        lines.append(
            f"        # Service {service_id}: {protocol}:{client_port} -> FRPS:{internal_port}"
        )
        lines.append(
            f"        ip6 daddr {sub_ipv6} {protocol} dport {client_port} "
            f"dnat to 127.0.0.1:{internal_port}"
        )
        lines.append("")

    # Close chains and table
    lines.extend(
        [
            "    }",
            "",
            "    chain postrouting {",
            "        type nat hook postrouting priority 100; policy accept;",
            "        # Automatic reverse NAT handled by conntrack",
            "    }",
            "}",
            "",
        ]
    )

    return "\n".join(lines)


def apply_nftables_rules(config: str) -> None:
    """Write nftables config to file and apply it.

    Args:
        config: Complete nftables configuration

    Raises:
        subprocess.CalledProcessError: If nft command fails
    """
    # Write config to file
    config_path = Path(settings.nftables_file)
    config_path.write_text(config)
    logger.debug(f"Wrote nftables config to {settings.nftables_file}")

    # Apply configuration
    try:
        result = subprocess.run(
            ["nft", "-f", settings.nftables_file],
            check=True,
            capture_output=True,
            text=True,
        )
        logger.debug(f"nft command output: {result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to apply nftables rules: {e.stderr}")
        raise


def main_loop():
    """Main service loop: fetch rules, generate config, apply rules."""
    logger.info("Starting nftables-manager service")
    logger.info(f"Backend URL: {settings.backend_url}")
    logger.info(f"Poll interval: {settings.poll_interval} seconds")

    consecutive_errors = 0
    max_consecutive_errors = 5

    while True:
        try:
            # Fetch rules from backend
            rules = fetch_rules()
            logger.info(f"Fetched {len(rules)} active service rules")

            # Generate nftables configuration
            config = generate_nftables_config(rules)

            # Apply rules
            apply_nftables_rules(config)
            logger.info(f"Successfully applied {len(rules)} nftables rules")

            # Reset error counter on success
            consecutive_errors = 0

        except requests.RequestException as e:
            consecutive_errors += 1
            logger.error(
                f"Backend API error ({consecutive_errors}/{max_consecutive_errors}): {e}"
            )

            if consecutive_errors >= max_consecutive_errors:
                logger.critical(
                    f"Too many consecutive errors ({consecutive_errors}), exiting"
                )
                sys.exit(1)

        except subprocess.CalledProcessError as e:
            consecutive_errors += 1
            logger.error(
                f"nftables error ({consecutive_errors}/{max_consecutive_errors}): {e}"
            )

            if consecutive_errors >= max_consecutive_errors:
                logger.critical(
                    f"Too many consecutive errors ({consecutive_errors}), exiting"
                )
                sys.exit(1)

        except Exception as e:
            logger.exception(f"Unexpected error: {e}")
            consecutive_errors += 1

            if consecutive_errors >= max_consecutive_errors:
                logger.critical(
                    f"Too many consecutive errors ({consecutive_errors}), exiting"
                )
                sys.exit(1)

        # Wait before next iteration
        time.sleep(settings.POLL_INTERVAL)


if __name__ == "__main__":
    try:
        main_loop()
    except KeyboardInterrupt:
        logger.info("Received shutdown signal, exiting gracefully")
        sys.exit(0)
