import logging
import subprocess
import sys
import time
from pathlib import Path
from typing import List

import requests

from pydantic_settings import BaseSettings, SettingsConfigDict
from devtools import pprint
import httpx

logger = logging.getLogger("nftables_manager")


class EnvironmentSettings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=str(Path(__file__).parent.parent / ".env"),
        env_file_encoding="utf-8",
        case_sensitive=False,
        extra="ignore",
    )

    backend_url: str
    poll_interval: int
    nftables_file: str
    log_level: str

    def model_post_init(self, __context):
        pprint(self)


settings = EnvironmentSettings()


def fetch_rules() -> List[dict]:
    response = httpx.get(f"http://{settings.backend_url}/services")
    return response.json()


def generate_nftables_config(rules: List[dict]) -> str:
    """Generate nftables configuration from service rules.

    Creates an IPv6 NAT table with DNAT rules that redirect traffic
    from user-facing IPv6:port to internal FRPS IPv4:port.

    Args:
        rules: List of service rule dictionaries

    Returns:
        Complete nftables configuration as string
    """
    lines = [
        "#!/usr/sbin/nft -f",
        "",
        "# YoLab IPv6 to IPv4 NAT rules",
        "# Auto-generated by nftables-manager",
        f"# Generated at: {time.strftime('%Y-%m-%d %H:%M:%S')}",
        f"# Total rules: {len(rules)}",
        "",
        "flush ruleset",
        "",
        "table ip6 nat {",
        "    chain prerouting {",
        "        type nat hook prerouting priority -100; policy accept;",
        "",
    ]

    # Add DNAT rule for each service
    for rule in rules:
        service_id = rule["service_id"]
        sub_ipv6 = rule["sub_ipv6"]
        client_port = rule["client_port"]
        protocol = rule["protocol"]
        internal_port = rule["frps_internal_port"]

        # Add comment and DNAT rule
        lines.append(
            f"        # Service {service_id}: {protocol}:{client_port} -> FRPS:{internal_port}"
        )
        lines.append(
            f"        ip6 daddr {sub_ipv6} {protocol} dport {client_port} "
            f"dnat to 127.0.0.1:{internal_port}"
        )
        lines.append("")

    # Close chains and table
    lines.extend(
        [
            "    }",
            "",
            "    chain postrouting {",
            "        type nat hook postrouting priority 100; policy accept;",
            "        # Automatic reverse NAT handled by conntrack",
            "    }",
            "}",
            "",
        ]
    )

    return "\n".join(lines)


def apply_nftables_rules(config: str) -> None:
    config_path = Path(settings.nftables_file)
    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(config)
    print(f"Wrote nftables config to {settings.nftables_file}")

    result = subprocess.run(
        ["nft", "-f", settings.nftables_file],
        check=True,
    )
    logger.debug(f"nft command output: {result.stdout}")


def main_loop():
    """Main service loop: fetch rules, generate config, apply rules."""
    logger.info("Starting nftables-manager service")
    logger.info(f"Backend URL: {settings.backend_url}")
    logger.info(f"Poll interval: {settings.poll_interval} seconds")

    consecutive_errors = 0
    max_consecutive_errors = 5

    while True:
        try:
            rules = fetch_rules()
            print(f"Fetched {len(rules)} active service rules")

            config = generate_nftables_config(rules)

            apply_nftables_rules(config)
            print(f"Successfully applied {len(rules)} nftables rules")

            consecutive_errors = 0

        except requests.RequestException as e:
            consecutive_errors += 1
            print(
                f"Backend API error ({consecutive_errors}/{max_consecutive_errors}): {e}"
            )

        except subprocess.CalledProcessError as e:
            consecutive_errors += 1
            print(
                f"nftables error ({consecutive_errors}/{max_consecutive_errors}): {e}"
            )

        except Exception as e:
            print(f"Unexpected error: {e}")
            consecutive_errors += 1

        time.sleep(settings.poll_interval)


if __name__ == "__main__":
    try:
        main_loop()
    except KeyboardInterrupt:
        logger.info("Received shutdown signal, exiting gracefully")
        sys.exit(0)
