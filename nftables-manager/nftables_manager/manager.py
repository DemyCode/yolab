import subprocess
import time
from pathlib import Path
from typing import List

import requests

from pydantic_settings import BaseSettings, SettingsConfigDict
from devtools import pprint
import httpx


class EnvironmentSettings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=str(Path(__file__).parent.parent / ".env"),
        env_file_encoding="utf-8",
        case_sensitive=False,
        extra="ignore",
    )

    backend_url: str
    poll_interval: int
    nftables_file: str
    log_level: str

    def model_post_init(self, __context):
        pprint(self)


settings = EnvironmentSettings()


def fetch_rules() -> List[dict]:
    response = httpx.get(f"http://{settings.backend_url}/services")
    return response.json()

def generate_nftables_config(rules: List[dict], server_ipv4: str = "127.0.0.1") -> str:
    """
    Generate nftables configuration using 'meta nfproto' to avoid
    family conflicts between IPv6 matches and IPv4 DNAT targets.
    """
    lines = [
        "#!/usr/sbin/nft -f",
        "",
        "# YoLab IPv6 to IPv4 NAT rules",
        "# Auto-generated by nftables-manager",
        f"# Generated at: {time.strftime('%Y-%m-%d %H:%M:%S')}",
        f"# Total rules: {len(rules)}",
        "",
        "flush ruleset",
        "",
        "table inet nat {",
        "    chain prerouting {",
        "        type nat hook prerouting priority dstnat; policy accept;",
        "",
    ]

    for rule in rules:
        service_id = rule["service_id"]
        sub_ipv6 = rule["sub_ipv6"]
        client_port = rule["client_port"]
        protocol = rule["protocol"]
        internal_port = rule["frps_internal_port"]

        lines.append(f"        # Service {service_id}: {protocol}:{client_port} -> FRPS:{internal_port}")
        
        # FIX: Added 'meta nfproto ipv6' at the start of the rule.
        # This allows the use of 'dnat ip to' for cross-family translation.
        lines.append(
            f"        meta nfproto ipv6 ip6 daddr {sub_ipv6} {protocol} dport {client_port} "
            f"dnat ip to {server_ipv4}:{internal_port}"
        )
        lines.append("")

    lines.extend([
        "    }",
        "",
        "    chain postrouting {",
        "        type nat hook postrouting priority srcnat; policy accept;",
        "        masquerade",
        "    }",
        "}",
        ""
    ])

    return "\n".join(lines)


def apply_nftables_rules(config: str) -> None:
    config_path = Path(settings.nftables_file)
    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(config)
    print(f"Wrote nftables config to {settings.nftables_file}")

    result = subprocess.run(
        ["nft", "-f", settings.nftables_file],
        check=True,
    )
    print(f"nft command output: {result.stdout}")


def main_loop():
    """Main service loop: fetch rules, generate config, apply rules."""
    print("Starting nftables-manager service")
    print(f"Backend URL: {settings.backend_url}")
    print(f"Poll interval: {settings.poll_interval} seconds")

    consecutive_errors = 0
    max_consecutive_errors = 5

    while True:
        try:
            rules = fetch_rules()
            print(f"Fetched {len(rules)} active service rules")

            config = generate_nftables_config(rules)

            apply_nftables_rules(config)
            print(f"Successfully applied {len(rules)} nftables rules")

            consecutive_errors = 0

        except requests.RequestException as e:
            consecutive_errors += 1
            print(
                f"Backend API error ({consecutive_errors}/{max_consecutive_errors}): {e}"
            )

        except subprocess.CalledProcessError as e:
            consecutive_errors += 1
            print(
                f"nftables error ({consecutive_errors}/{max_consecutive_errors}): {e}"
            )

        except Exception as e:
            print(f"Unexpected error: {e}")
            consecutive_errors += 1

        time.sleep(settings.poll_interval)
