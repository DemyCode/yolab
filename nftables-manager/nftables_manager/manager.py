import subprocess
import time
from pathlib import Path
from typing import List

import requests

from pydantic_settings import BaseSettings, SettingsConfigDict
from devtools import pprint
import httpx


class EnvironmentSettings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=str(Path(__file__).parent.parent / ".env"),
        env_file_encoding="utf-8",
        case_sensitive=False,
        extra="ignore",
    )

    backend_url: str
    poll_interval: int
    nftables_file: str
    log_level: str

    def model_post_init(self, __context):
        pprint(self)


settings = EnvironmentSettings()


def fetch_rules() -> List[dict]:
    response = httpx.get(f"http://{settings.backend_url}/services")
    return response.json()


import subprocess
import signal
import os
import atexit

# Dictionary to keep track of active socat processes
# Key: (sub_ipv6, client_port, protocol, internal_port)
# Value: subprocess.Popen object
active_relays = {}


def cleanup_relays():
    """Terminate all active socat processes on shutdown."""
    print("Shutting down all active relays...")
    for key, proc in list(active_relays.items()):
        print(f"Stopping relay: {key}")
        proc.terminate()
        try:
            proc.wait(timeout=5)
        except subprocess.TimeoutExpired:
            proc.kill()
    active_relays.clear()
    print("All relays stopped")


# Register cleanup on exit
atexit.register(cleanup_relays)


def reconcile_relays(desired_rules: list, server_ipv4: str = "127.0.0.1"):
    """
    Declaratively syncs running socat processes with the desired state.
    """
    global active_relays
    desired_keys = set()
    for rule in desired_rules:
        key = (
            rule["sub_ipv6"],
            rule["client_port"],
            rule["protocol"].lower(),
            rule["frps_internal_port"],
        )
        desired_keys.add(key)
    for key in list(active_relays.keys()):
        if key not in desired_keys:
            print(f"[-] Stopping redundant relay: {key}")
            active_relays[key].terminate()
            del active_relays[key]
    for key in desired_keys:
        sub_ipv6, client_port, protocol, internal_port = key
        if key not in active_relays:
            print(
                f"[+] Starting relay: {sub_ipv6}:{client_port} -> {server_ipv4}:{internal_port}"
            )
            listen_type = "TCP6-LISTEN" if protocol == "tcp" else "UDP6-RECVFROM"
            forward_type = "TCP4" if protocol == "tcp" else "UDP4"
            cmd = [
                "socat",
                f"{listen_type}:{client_port},bind=[{sub_ipv6}],fork,reuseaddr",
                f"{forward_type}:{server_ipv4}:{internal_port}",
            ]
            proc = subprocess.Popen(
                cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
            )
            active_relays[key] = proc


# Example Usage:
# rules = api.get_rules()
# reconcile_relays(rules)


def generate_nftables_config(rules: List[dict], server_ipv4: str = "127.0.0.1") -> str:
    """
    Generate nftables configuration for IPv6 to IPv4 NAT.
    Uses 'table ip6' to explicitly support NAT64 (IPv6 -> IPv4 translation).
    """
    lines = [
        "#!/usr/sbin/nft -f",
        "",
        "# YoLab IPv6 to IPv4 NAT rules",
        "# Auto-generated by nftables-manager",
        f"# Generated at: {time.strftime('%Y-%m-%d %H:%M:%S')}",
        f"# Total rules: {len(rules)}",
        "",
        "flush ruleset",
        "",
        # Using 'ip6' family here is the key to solving the 'family not supported' error
        "table ip6 nat {",
        "    chain prerouting {",
        "        type nat hook prerouting priority dstnat; policy accept;",
        "",
    ]

    for rule in rules:
        service_id = rule["service_id"]
        sub_ipv6 = rule["sub_ipv6"]
        client_port = rule["client_port"]
        protocol = rule["protocol"]
        internal_port = rule["frps_internal_port"]

        lines.append(
            f"        # Service {service_id}: {protocol}:{client_port} -> FRPS:{internal_port}"
        )

        # In the ip6 table, 'dnat to' followed by an IPv4 address is the standard
        # way to perform cross-protocol translation.
        lines.append(
            f"        ip6 daddr {sub_ipv6} {protocol} dport {client_port} "
            f"dnat to {server_ipv4}:{internal_port}"
        )
        lines.append("")

    lines.extend(
        [
            "    }",
            "",
            "    chain postrouting {",
            "        type nat hook postrouting priority srcnat; policy accept;",
            "        # Masquerade ensures the IPv4 stack knows how to route back to the NAT engine",
            "        masquerade",
            "    }",
            "}",
            "",
        ]
    )

    return "\n".join(lines)


def apply_nftables_rules(config: str) -> None:
    config_path = Path(settings.nftables_file)
    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(config)
    print(f"Wrote nftables config to {settings.nftables_file}")

    result = subprocess.run(
        ["nft", "-f", settings.nftables_file],
        check=True,
    )
    print(f"nft command output: {result.stdout}")


def main_loop():
    """Main service loop: fetch rules, reconcile socat relays."""
    print("Starting nftables-manager service")
    print(f"Backend URL: {settings.backend_url}")
    print(f"Poll interval: {settings.poll_interval} seconds")

    consecutive_errors = 0
    max_consecutive_errors = 5

    while True:
        try:
            rules = fetch_rules()
            print(f"Fetched {len(rules)} active service rules")

            reconcile_relays(rules)
            print(f"Successfully reconciled {len(rules)} relay rules")

            consecutive_errors = 0

        except requests.RequestException as e:
            consecutive_errors += 1
            print(
                f"Backend API error ({consecutive_errors}/{max_consecutive_errors}): {e}"
            )

        except (subprocess.CalledProcessError, OSError) as e:
            consecutive_errors += 1
            print(f"Relay error ({consecutive_errors}/{max_consecutive_errors}): {e}")

        except Exception as e:
            print(f"Unexpected error: {e}")
            consecutive_errors += 1

        time.sleep(settings.poll_interval)
